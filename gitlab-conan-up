#!/Library/Frameworks/Python.framework/Versions/3.6/bin/python3
import argparse
import json
import os
import re
import shutil
import subprocess
import tempfile
import urllib3
from concurrent.futures import ThreadPoolExecutor
from concurrent.futures import as_completed


class Gitlab:
    def __init__(self, url, token, workdir):
        self._url = url
        self._token = token
        self._workdir = workdir
        self._pattern = re.compile('([^/]*)/([^@]*)@')
        urllib3.disable_warnings()

    def get_source(self, package):
        folder = os.path.join(self._workdir, package.split('/')[-1])
        url = 'https://gitlab-ci-token:{token}@{gitlab}/{package}'.format(token=self._token, gitlab=self._url,
                                                                          package=package)
        print('URL: %s' % url)
        if subprocess.call(['git', 'clone', url, folder]) != 0:
            exit('Failed to clone {package}'.format(package=package))
        return folder

    def get_projects(self, group):
        http = urllib3.PoolManager()
        r = http.request(
            method='GET',
            url='https://{gitlab}/api/v4/groups/{id}/projects'.format(id=group.replace('/', '%2F'), gitlab=self._url),
            headers={'Private-Token': self._token},
        )
        return json.loads(r.data.decode())

    def get_file(self, project, folder, file):
        http = urllib3.PoolManager()
        r = http.request(
            method='GET',
            url='https://{gitlab}/api/v4/projects/{id}/repository/files/{file}/raw?ref=master'.
                format(id=project.replace('/', '%2F'), gitlab=self._url, file=file),
            headers={'Private-Token': self._token},
        )
        if r.status == 200:
            with open(os.path.join(folder, file), 'wb') as fd:
                fd.write(r.data)
            return True
        return False

    def conan_read_deps(self, folder):
        info = subprocess.Popen(['conan', 'info', '-n', 'None', folder], stdout=subprocess.PIPE,
                                stderr=subprocess.DEVNULL)
        version = info.stdout.readline().decode().strip()
        if version.find('PROJECT') == -1:
            if info.returncode != 0:
                return None, None
            info = subprocess.Popen(['conan', 'info', '-n', 'None', folder], stdout=subprocess.PIPE,
                                    stderr=subprocess.DEVNULL)
            version = info.stdout.readline().decode().strip()
            if version.find('PROJECT') == -1:
                return None, None
        deps = {}
        for line in info.stdout:
            data = line.decode().strip()
            res = self._pattern.search(data)
            if res:
                deps[res.group(1)] = res.group(2)
        return deps, version

    def get_conan_versions(self, project):
        with tempfile.TemporaryDirectory() as folder:
            if self.get_file(project, folder, 'conanfile.py'):
                deps, version = self.conan_read_deps(folder)
                if deps is not None:
                    version = self._pattern.search(version)
                    return project, version.group(1), version.group(2), deps
            elif self.get_file(project, folder, 'conanfile.txt'):
                deps, version = self.conan_read_deps(folder)
                if deps is not None:
                    return project, None, None, deps
        return None, None, None, None

    def deps_version_up(self, content, up_map):
        for old, val in up_map.items():
            content = content.replace('"' + old + '"', '"' + val + '"')
            content = content.replace("'" + old + "'", "'" + val + "'")
        return content

    def package_version_up(self, content):
        version = re.search(r'''^\s+version\s*=\s*['"]([^'"]*).*$''', content, re.MULTILINE)

        values = version.group(1).split('.')
        if values[-1].endswith(suffix):
            values[-1] = str(int(values[0:len(values[-1]) - 1]) + 1) + suffix
        else:
            values.append('1' + suffix)

        content = content[0:version.start(1)] + '.'.join(values) + content[version.end(1):]
        return '.'.join(values)

    def upload(self, folder):
        subprocess.call(['git', 'checkout', '-b', 'version/' + version], cwd=folder)
        subprocess.call(['git', 'commit', '-a', '-m', 'Upgrade versnios for conan packages'], cwd=folder)
        subprocess.call(['git', 'push', 'origin', 'version/' + version], cwd=folder)
        http = urllib3.PoolManager()
        r = http.request(
            method='POST',
            url=self._url + '/api/v4/projects/{id}/merge_requests'.format(id=project_id.replace('/', '%2F')),
            headers={'Private-Token': self._token},
            fields={
                'source_branch': 'version/' + version,
                'target_branch': 'master',
                'title': 'Version UP to ' + version,
                'remove_source_branch': 'true',
                'merge_when_pipeline_succeeds': 'true'
            },

        )
        result = json.loads(r.data.decode())
        status = ''
        while status != 'success':
            r1 = http.request(
                method='GET',
                url=self._url + '/api/v4/projects/{id}/merge_requests/{merge_iid}/pipelines'.format(id=result['project_id'], merge_iid=result["iid"])
            )
            tmp = json.loads(r1.data.decode())
            status = tmp[0]["status"]
            if status == "failed":
                exit("Failed to build")
            time.sleep(5)

        http.request(
            method='PUT',
            url=self._url + '/api/v4/projects/{id}/merge_requests/{merge_iid}/merge'.format(id=result['project_id'], merge_iid=result["iid"]),
            headers={'Private-Token': self._token},
        )


        pipeline_id = result["pipeline"]["id"]
        status = ''
        while status != 'success':
            r1 = http.request(
                method='GET',
                url=self._url + '/api/v4/projects/{id}/pipelines/{pipeline_id}'.format(id=result['project_id'], pipeline_id=pipeline_id)
            )
            tmp = json.loads(r1.data.decode())
            status = next((pipeline["status"] for pipeline in tmp if pipeline["id"] == pipeline_id))
            if status == "failed":
                exit("Failed to build")
            time.sleep(5)
        return package.name + '/' + version + '@' + package.author

    def up(self, project):
        print('UPDATE %s' % project)
        folder = self.get_source(project)
        conanfile = os.path.join(folder, 'conanfile.py')
        if os.path.isfile(conanfile):
            with open(conanfile, 'r') as fd:
                content = fd.read()
            new_content = self.deps_version_up(content, versions)
            if new_content != content:
                new_content, version = self.package_version_up(new_content)
                upload()
                return project, version

        else:
            conanfile = os.path.join(folder, 'conanfile.txt')
            with open(conanfile, 'r') as fd:
                content = fd.read()
            if update_version(content, versions):
                upload()

        return None, None


def version_less(first, second):
    if first == second:
        return False
    f = first.split('.')
    s = second.split('.')
    for i in range(min(len(f), len(s))):
        if f[i] == s[i]:
            continue
        if f[i].isdecimal() and s[i].isdecimal():
            return int(f[i]) < int(s[i])
        else:
            return f[i] < s[i]
    return len(f) < len(s)


def update_version(versions, dep_name, dep_ver):
    if dep_name in versions:
        if version_less(versions[dep_name], dep_ver):
            versions[dep_name] = dep_ver
    else:
        versions[dep_name] = dep_ver


parser = argparse.ArgumentParser(description='Conan package version updater')
parser.add_argument('--gitlab', help='GitLab URL', required=True)
parser.add_argument('--gitlab-token', help='GitLab private token', required=True)
parser.add_argument('groups', help='gitlab goup list to update. All conan packages in this group will be updated', nargs='+')
args = parser.parse_args()

with tempfile.TemporaryDirectory() as workdir:
    print("Working directory: %s" % workdir)
    gitlab = Gitlab(args.gitlab, args.gitlab_token, workdir)
    for group in args.groups:
        versions = {}
        packages = {}
        projects = {}
        gitlab_projects = gitlab.get_projects(group)
        with ThreadPoolExecutor(max_workers=4) as executor:
            pkgs = (executor.submit(Gitlab.get_conan_versions, gitlab, str(project['path_with_namespace'])) for project in gitlab_projects)
            for future in as_completed(pkgs):
                project, package, package_ver, package_deps = future.result()
                if project is not None:
                    for dep_name, dep_ver in package_deps.items():
                        print('Project %s pkg %s/%s depend %s %s' % (project, package, package_ver, dep_name, dep_ver))
                        update_version(versions, dep_name, dep_ver)
                    if package is not None:
                        update_version(versions, package, package_ver)
                    projects[project] = package_deps
                    packages[project] = package
            while len(packages) > 0:
                to_update = [project for project, package_deps in projects.items()
                             if next((dep_name for dep_name in package_deps if dep_name in packages.values()), None) is None]
                if len(to_update) == 0:
                    for pkg, deps in packages.values():
                        print('Left %s %s' % (pkg, ','.join(deps.keys())))
                    exit('Loop detected')
                print('='*30)
                pkgs = (executor.submit(Gitlab.up, gitlab, project) for project in to_update)
                for project in to_update:
                    del packages[project]
                    del projects[project]
                for future in as_completed(pkgs):
                    pkg, pkg_ver = future.result()
                    versions[pkg] = pkg_ver
